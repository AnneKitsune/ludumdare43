COMPILE TIME

Item definition : Scriptable object
-M1 garant
--weapon : Data : Scriptable object  (Key, Value) or 
---damage
---bulletcapacity
---fire rate
---damage drop off
--srv spawn info
--tooltip
---color = blue
---rarity = common


RUN TIME

Item stack : MonoBehaviour
-itemdef = m1 garant
-stack = 1
-modifiers : T: Data ApplyChange(Data d)
--Enchant
---Damage += 5
---damge drop off redux 5% per shot
---damage += 2
---tooltip color modifier = purple


onstart or if itemstack modifiers change, copy itemdef and apply changes to data


or just have a script on an item object


for the inventory, have a list of gameoject?



amethyst fps

Player
-PlayerHead (fly cam)
--Camera
--item



amethyst UI layouting

// Y,X naming
enum Anchor{
	TopLeft,
	TopMiddle,
	TopRight,
	MiddleLeft,
	Middle,
	MiddleRight,
	BottomLeft,
	BottomMiddle,
	BottomRight,
}

enum Stretch{
	X,
	Y,
	Both,
}

// Relative to parent
struct Anchored{
	anchor: Anchor,
	offset: Option<(f32,f32)>, // Defaults to none. If it is none, set to some using UiTransform position
}
impl Component for Anchored

AnchoredSystem{
	(UiTransform,Anchored)

	if anchor.offset = None{
		anchor.offset = transform.offset
	}
}

struct Stretched{
	stretch: Stretch,
	margin: (f32,f32) //default to 0,0; in builder use .with_margin
}

impl Component for Stretched

// Used when receiving a UiEvent. You can check if the event entity has a tag, and what it is
// (&event.entity,UiTag<String>).join()
// if tag == "Exit button" {...}
struct UiTag<T> where T: PartialEq{
	tag: T,
}

impl Component for UiTag

// UI Builder
// The macro will generate a list of entities.
// It uses the builder pattern for each ui element
// DECLARATIVE SYNTAX
!buildui{
	Button("btn1",0,0).with_anchor(LeftTop),
	DropDownList([elements],20,20).stretched(Stretch::X)
}

// Ui file format is just a serialize of the different builders data.

// Ui manual format is by manually creating entities in the world with the proper components.

//Example button builder
struct ButtonBuilder{
	name: &str,
	posx: f32, //Offset it there's a parent
	posy: f32,
	anchor: Option<Anchored>,
	stretched: Option<Stretched>,
}

// For all of this to work, the UiTransform should indicate the MIDDLE of the ui element!!!!!!!!!

//Button sample structure, generated by the button builder, or macro btn!
ButtonEntity
Comps:[
	UiTransform,
	Anchored,
	Stretched,
]
-TextEntity as child
-Comps:[
	UiTransform,
	UiText,
	Anchored,
]




Questions QCM particle system

1) Quel module contrôle la vitesse (temps entre les spawns) à laquelle les particules sont créées?
a) Shape
b) General
c) Speed over lifetime
d) Emission <-----
e) Autre réponse

2) Où faut-il mettre un material afin de voir une trail?
a) Material
b) Render mode
c) Render alignment
d) Trail mode
e) Autre réponse <---- Trail material

3) Quel module et option permettent de changer la variation aléatoire de la position d'une particule?
a) Noise + Strength <------
b) Speed over lifetime + Curve
c) Noise + Force
d) Size by speed + Ratio
e) Aucune de ces réponses

4) Quel mode (Type) permet aux particules d'entrer en collision avec tout les colliders?
a) Plane
b) Colliders
c) World <------
d) All
e) Aucune de ces réponses

5) Quelle shape n'est pas une option du Shape module?
a) Sphere
b) Hemisphere
c) Cone
d) Box
e) Aucune de ces réponses <-----